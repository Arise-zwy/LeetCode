leetcode983:最低票价

关键字：动态规划（从后往前）

思路：对于每一天而言有两种状态，今天出门和今天不出门。不出门就好办了，即不出门当天没有花钱买票。如果当天出门了，那么可能是三种票中的一种。如何选择票种就成了问题。
由于选择票种受之后出行天数的影响，下面的假设都基于当天要出行，假设第i天。

1、倘若第i天后的30天内都没有出行计划，那么第i天买1日票
2、倘若第i天后的30天内有出行计划，那么第i天可能买7日票，也可能买30日票

综上，第i天受之后的影响，那么应该从后往前考虑。

考虑定义dp[i]，该含义为：从第i天开始到最后一天，花费的最小费用
因为每个票种影响的天数不同，且有各自的限制区域，因此需要在选择不同的票种后，考虑其后续的影响
比如：
一天票，dp[i]=cost[0]+dp[i+1]，只影响当天出行第i天，在dp[i+1]天的基础上
七天票，dp[i]=cost[1]+dp[i+7]，影响当天出行第i天到第i+6天，在dp[i+7]天的基础上
三十天票，dp[i]=cost[2]+dp[i+30]，影响当天出行第i天到第i+29天，在dp[i+30]天的基础上



题解：
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        //判断当天是否需要出门旅行
        //判断当天出门旅行需要购买哪张通行证

        //记录哪些天需要出门
        unordered_set<int> s;
        for (auto day : days) {
            s.insert(day);
        }

        //一共有365天可能有出行安排，+30是为了防止最后一天计算下标越界
        vector<int> dp(366 + 30);
        
        for (int i = 365; i >= 1; i--) {
            //当天如果需要出行
            if (s.count(i)) {
                dp[i] = min(costs[0] + dp[i + 1], min(costs[1] + dp[i + 7], costs[2] + dp[i + 30]));
            }
            //当天不需要出行
            else {
                dp[i] = dp[i + 1];
            }
        }

        return dp[1];

    }
};
