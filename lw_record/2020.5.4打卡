leetcode55:跳跃游戏
关键字：贪心算法

题目描述：
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。

题解：
class Solution {
public:
    bool canJump(vector<int>& nums) {
        
        //思路：假设起跳点的位置是x，那么从x能跳到的最远距离是x+nums[x]
        //而且，x能跳到x+nums[x]左边任意一个位置。而我们只需要关注跳到的最远位置即可。
        //遍历整个数组，求得每个位置能够跳到的最远距离（局部最远距离），并且不断更新整体的全局最远距离
        //此处的局部最远距离需要加以说明
        //例如：[4,2,1,1,0]
        //对于index=0，val=4而言，其最远距离可以调到index=4，val=0处。此时对于index=0而言，其局部最远距离是index=4，全局也是4
        //对于index=1，val=2而言，其最远距离可以跳到index=3，val=3处。此时对于index=1而言，其局部最远距离是index=3，全局仍是4
        //也就是说前面位置的最远距离有可能影响甚至覆盖后面位置的最远距离
        
        int len = nums.size();
        int maxpos = 0;//对于当前点而言能跳到的最远距离
        for (int i = 0; i < len; i++) {
            //如果最远距离无法跳到位置i，那么不管i能不能跳到最后一个元素，都无法满足题意
            if (i > maxpos) return false;
            //更新当前位置的全局最远距离，也就是将此时的局部和上一次的全局进行比较
            maxpos = max(maxpos, i + nums[i]);
        }
        return true;
    }
};

############################################################################
leetcode45:跳跃游戏Ⅱ
关键字：贪心算法

题目描述：
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
示例:
输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

题解：
class Solution {
public:
    int jump(vector<int>& nums) {
        //贪心贪就贪在，对于当前位置nums[i]而言，其有0---i种可以跳的选择，但为了满足题意，尽力挑选的落脚点其下一次最远距离要尽量大
        //这样就能尽可能的跳的远，等跳到终点的时候，跳的次数也就很少了
        //例如，对于nums=[2,3,5,1,2,3]而言，index=0，val=2其可以跳到index=1，val=3，或者index=2，val=5两个位置上
        //根据上述贪心的思路，应该选择跳到index=2，val=5上
        
        int len = nums.size();
        int maxpos = 0;//对于当前点而言能跳到的最远距离
        int end = 0, step = 0;

        //遍历数组
        for (int i = 0; i < len-1; i++) {
        
            //该约束条件保证每一次跳，都是有效的
            if (i <= maxpos) {
                maxpos = max(maxpos, i + nums[i]);

                //到达边界，即之前maxpos的位置
                if (i == end) {
                    end = maxpos;//更新边界值
                    step++;//计数
                }
            }
        }

        return step;
    }
};
